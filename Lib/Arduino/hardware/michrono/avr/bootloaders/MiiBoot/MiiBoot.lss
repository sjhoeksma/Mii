
MiiBoot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  00007f84  00000818  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000784  00007800  00007800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002a0  0080010a  0080010a  00000822  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00000822  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000f8  00000000  00000000  00000838  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001274  00000000  00000000  00000930  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000433  00000000  00000000  00001ba4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000041a  00000000  00000000  00001fd7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001e4  00000000  00000000  000023f4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000667  00000000  00000000  000025d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000b38  00000000  00000000  00002c3f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000150  00000000  00000000  00003777  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <__vectors>:
    7800:	0c 94 34 3c 	jmp	0x7868	; 0x7868 <__ctors_end>
    7804:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7808:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    780c:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7810:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7814:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7818:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    781c:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7820:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7824:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7828:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    782c:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7830:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7834:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7838:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    783c:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7840:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7844:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7848:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    784c:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7850:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7854:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7858:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    785c:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7860:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>
    7864:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__bad_interrupt>

00007868 <__ctors_end>:
    7868:	11 24       	eor	r1, r1
    786a:	1f be       	out	0x3f, r1	; 63
    786c:	cf ef       	ldi	r28, 0xFF	; 255
    786e:	d8 e0       	ldi	r29, 0x08	; 8
    7870:	de bf       	out	0x3e, r29	; 62
    7872:	cd bf       	out	0x3d, r28	; 61

00007874 <__do_copy_data>:
    7874:	11 e0       	ldi	r17, 0x01	; 1
    7876:	a0 e0       	ldi	r26, 0x00	; 0
    7878:	b1 e0       	ldi	r27, 0x01	; 1
    787a:	e4 e8       	ldi	r30, 0x84	; 132
    787c:	ff e7       	ldi	r31, 0x7F	; 127
    787e:	02 c0       	rjmp	.+4      	; 0x7884 <__do_copy_data+0x10>
    7880:	05 90       	lpm	r0, Z+
    7882:	0d 92       	st	X+, r0
    7884:	aa 30       	cpi	r26, 0x0A	; 10
    7886:	b1 07       	cpc	r27, r17
    7888:	d9 f7       	brne	.-10     	; 0x7880 <__do_copy_data+0xc>

0000788a <__do_clear_bss>:
    788a:	23 e0       	ldi	r18, 0x03	; 3
    788c:	aa e0       	ldi	r26, 0x0A	; 10
    788e:	b1 e0       	ldi	r27, 0x01	; 1
    7890:	01 c0       	rjmp	.+2      	; 0x7894 <.do_clear_bss_start>

00007892 <.do_clear_bss_loop>:
    7892:	1d 92       	st	X+, r1

00007894 <.do_clear_bss_start>:
    7894:	aa 3a       	cpi	r26, 0xAA	; 170
    7896:	b2 07       	cpc	r27, r18
    7898:	e1 f7       	brne	.-8      	; 0x7892 <.do_clear_bss_loop>
    789a:	0e 94 51 3c 	call	0x78a2	; 0x78a2 <main>
    789e:	0c 94 c0 3f 	jmp	0x7f80	; 0x7f80 <_exit>

000078a2 <main>:
#else
int main(void)
#endif
 {
	/* here we learn how we were reset */
	reset_reason = MCUSR;
    78a2:	84 b7       	in	r24, 0x34	; 52
    78a4:	80 93 0a 01 	sts	0x010A, r24
	MCUSR = 0;
    78a8:	14 be       	out	0x34, r1	; 52

	/* stop watchdog */
	WDTCSR |= _BV(WDCE) | _BV(WDE);
    78aa:	80 91 60 00 	lds	r24, 0x0060
    78ae:	88 61       	ori	r24, 0x18	; 24
    78b0:	80 93 60 00 	sts	0x0060, r24
	WDTCSR = 0;
    78b4:	10 92 60 00 	sts	0x0060, r1
#ifdef BOOT_LOADER
	/* start app right ahead if this was not an external reset */
	/* this means that all the code below this line is only executed on external reset */
	if (!(reset_reason & _BV(EXTRF))) app_start();
    78b8:	80 91 0a 01 	lds	r24, 0x010A
    78bc:	81 fd       	sbrc	r24, 1
    78be:	05 c0       	rjmp	.+10     	; 0x78ca <main+0x28>
    78c0:	e0 91 0b 01 	lds	r30, 0x010B
    78c4:	f0 91 0c 01 	lds	r31, 0x010C
    78c8:	09 95       	icall

	/* this is needed because of the __attribute__ naked, section .init 9 */
	/* from now, we can call functions :-) */
	asm volatile ( "clr __zero_reg__" );
    78ca:	11 24       	eor	r1, r1
	SP=RAMEND;
    78cc:	8f ef       	ldi	r24, 0xFF	; 255
    78ce:	98 e0       	ldi	r25, 0x08	; 8
    78d0:	9e bf       	out	0x3e, r25	; 62
    78d2:	8d bf       	out	0x3d, r24	; 61
 
#ifdef UART_DEBUG
    UART_init();
#endif

   LED_DDR |= 1<<LED_PIN; 	//LED -> Output
    78d4:	56 9a       	sbi	0x0a, 6	; 10
   LED_PORT &= ~(1<<LED_PIN);   //LED  -> Low (activate)
    78d6:	5e 98       	cbi	0x0b, 6	; 11
*/
static inline unsigned char mmc_init(void)
{
	// the default after reset is already input
	//SPI_DDR &= ~(1<<SPI_MISO);	//SPI Data Out -> Input (default)
	SPI_PORT |= 1<<SPI_SS;   //PB2 output: High (deselect other SPI chips)
    78d8:	2a 9a       	sbi	0x05, 2	; 5
	SPI_DDR  |= 1<<SPI_CLK | 1<<SPI_MOSI | 1<<SPI_SS; // SPI Data -> Output
    78da:	84 b1       	in	r24, 0x04	; 4
    78dc:	8c 62       	ori	r24, 0x2C	; 44
    78de:	84 b9       	out	0x04, r24	; 4
        SPCR = 1<<SPE | 1<<MSTR | SPI_INIT_CLOCK; //SPI Enable, SPI Master Mode
    78e0:	83 e5       	ldi	r24, 0x53	; 83
    78e2:	8c bd       	out	0x2c, r24	; 44
    78e4:	ca e0       	ldi	r28, 0x0A	; 10

	unsigned char i;
	
	i=10;
	while(i) { //Pulse 80+ clocks to reset MMC
		spi_send_byte(0xFF);	
    78e6:	8f ef       	ldi	r24, 0xFF	; 255
    78e8:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
    78ec:	c1 50       	subi	r28, 0x01	; 1
        #endif

	unsigned char i;
	
	i=10;
	while(i) { //Pulse 80+ clocks to reset MMC
    78ee:	d9 f7       	brne	.-10     	; 0x78e6 <main+0x44>
 		i--;
	}

	unsigned char res;

	cmd[0] = 0x40 + MMC_GO_IDLE_STATE;
    78f0:	80 e4       	ldi	r24, 0x40	; 64
    78f2:	80 93 22 01 	sts	0x0122, r24
	cmd[1] = 0x00; cmd[2] = 0x00; cmd[3] = 0x00; cmd[4] = 0x00; cmd[5] = 0x95;
    78f6:	10 92 23 01 	sts	0x0123, r1
    78fa:	10 92 24 01 	sts	0x0124, r1
    78fe:	10 92 25 01 	sts	0x0125, r1
    7902:	10 92 26 01 	sts	0x0126, r1
    7906:	85 e9       	ldi	r24, 0x95	; 149
    7908:	80 93 27 01 	sts	0x0127, r24
    790c:	c0 e1       	ldi	r28, 0x10	; 16
	
	for (i=0; i<MMC_CMD0_RETRY; i++)
	{
		res=send_cmd(); //store result of reset command, should be 0x01
    790e:	0e 94 45 3e 	call	0x7c8a	; 0x7c8a <send_cmd>
    7912:	d8 2f       	mov	r29, r24

		MMC_PORT |= 1<<MMC_CS; //MMC Chip Select -> High (deactivate mmc);
    7914:	2a 9a       	sbi	0x05, 2	; 5
      	 	spi_send_byte(0xFF);
    7916:	8f ef       	ldi	r24, 0xFF	; 255
    7918:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
		if (res == 0x01)
    791c:	d1 30       	cpi	r29, 0x01	; 1
    791e:	09 f4       	brne	.+2      	; 0x7922 <main+0x80>
    7920:	83 c1       	rjmp	.+774    	; 0x7c28 <main+0x386>
    7922:	c1 50       	subi	r28, 0x01	; 1
	unsigned char res;

	cmd[0] = 0x40 + MMC_GO_IDLE_STATE;
	cmd[1] = 0x00; cmd[2] = 0x00; cmd[3] = 0x00; cmd[4] = 0x00; cmd[5] = 0x95;
	
	for (i=0; i<MMC_CMD0_RETRY; i++)
    7924:	a1 f7       	brne	.-24     	; 0x790e <main+0x6c>
    7926:	7c c1       	rjmp	.+760    	; 0x7c20 <main+0x37e>
		
//May be this becomes an endless loop ?
//Counting i from 0 to 255 and then timeout
//was to SHORT for some of my cards !
	while(send_cmd() != 0) {
		MMC_PORT |= 1<<MMC_CS; //MMC Chip Select -> High (deactivate);
    7928:	2a 9a       	sbi	0x05, 2	; 5
		spi_send_byte(0xFF);
    792a:	8f ef       	ldi	r24, 0xFF	; 255
    792c:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
	cmd[0]=0x40 + MMC_SEND_OP_COND;
		
//May be this becomes an endless loop ?
//Counting i from 0 to 255 and then timeout
//was to SHORT for some of my cards !
	while(send_cmd() != 0) {
    7930:	0e 94 45 3e 	call	0x7c8a	; 0x7c8a <send_cmd>
    7934:	81 11       	cpse	r24, r1
    7936:	f8 cf       	rjmp	.-16     	; 0x7928 <main+0x86>
    7938:	7b c1       	rjmp	.+758    	; 0x7c30 <main+0x38e>
	if (mmc_init() != MMC_OK) return 1;
	
    mmc_start_read_block(0);

    // Try sector 0 as a bootsector
	if ((vbr->bsFileSysType[0] == 'F') && (vbr->bsFileSysType[4] == '6'))
    793a:	80 91 e4 01 	lds	r24, 0x01E4
    793e:	86 33       	cpi	r24, 0x36	; 54
    7940:	29 f4       	brne	.+10     	; 0x794c <main+0xaa>
	{
		FATRegionStartSec = 0;
    7942:	10 92 18 01 	sts	0x0118, r1
    7946:	10 92 17 01 	sts	0x0117, r1
    794a:	18 c0       	rjmp	.+48     	; 0x797c <main+0xda>
	}
	else // Try sector 0 as a MBR	
	{     	 
		FATRegionStartSec = mbr->sector.partition[0].sectorOffset;
    794c:	60 91 70 03 	lds	r22, 0x0370
    7950:	70 91 71 03 	lds	r23, 0x0371
    7954:	80 91 72 03 	lds	r24, 0x0372
    7958:	90 91 73 03 	lds	r25, 0x0373
    795c:	70 93 18 01 	sts	0x0118, r23
    7960:	60 93 17 01 	sts	0x0117, r22
          
		mmc_start_read_block(mbr->sector.partition[0].sectorOffset);
    7964:	0e 94 60 3e 	call	0x7cc0	; 0x7cc0 <mmc_start_read_block>
	  
        if ((vbr->bsFileSysType[0] != 'F') || (vbr->bsFileSysType[4] != '6'))
    7968:	80 91 e0 01 	lds	r24, 0x01E0
    796c:	86 34       	cpi	r24, 0x46	; 70
    796e:	09 f0       	breq	.+2      	; 0x7972 <main+0xd0>
    7970:	57 c1       	rjmp	.+686    	; 0x7c20 <main+0x37e>
    7972:	80 91 e4 01 	lds	r24, 0x01E4
    7976:	86 33       	cpi	r24, 0x36	; 54
    7978:	09 f0       	breq	.+2      	; 0x797c <main+0xda>
    797a:	52 c1       	rjmp	.+676    	; 0x7c20 <main+0x37e>
		   return 2; // No FAT16 found
     }
    
	SectorsPerCluster  			= vbr->bsSecPerClus; // 4
    797c:	80 91 b7 01 	lds	r24, 0x01B7
    7980:	80 93 19 01 	sts	0x0119, r24
	
	// Calculation Algorithms
	FATRegionStartSec			+= vbr->bsRsvdSecCnt;						// 6
    7984:	80 91 b8 01 	lds	r24, 0x01B8
    7988:	90 91 b9 01 	lds	r25, 0x01B9
    798c:	20 91 17 01 	lds	r18, 0x0117
    7990:	30 91 18 01 	lds	r19, 0x0118
    7994:	82 0f       	add	r24, r18
    7996:	93 1f       	adc	r25, r19
    7998:	90 93 18 01 	sts	0x0118, r25
    799c:	80 93 17 01 	sts	0x0117, r24
	RootDirRegionStartSec	 	= FATRegionStartSec + (vbr->bsNumFATs * vbr->bsNrSeProFAT16);		// 496	
    79a0:	40 91 ba 01 	lds	r20, 0x01BA
    79a4:	20 91 c0 01 	lds	r18, 0x01C0
    79a8:	30 91 c1 01 	lds	r19, 0x01C1
    79ac:	42 9f       	mul	r20, r18
    79ae:	80 01       	movw	r16, r0
    79b0:	43 9f       	mul	r20, r19
    79b2:	10 0d       	add	r17, r0
    79b4:	11 24       	eor	r1, r1
    79b6:	08 0f       	add	r16, r24
    79b8:	19 1f       	adc	r17, r25
    79ba:	10 93 21 01 	sts	0x0121, r17
    79be:	00 93 20 01 	sts	0x0120, r16
	RootDirRegionSize		 	= (vbr->bsRootEntCnt / 16); 						// 32
    79c2:	e0 90 bb 01 	lds	r14, 0x01BB
    79c6:	f0 90 bc 01 	lds	r15, 0x01BC
    79ca:	b4 e0       	ldi	r27, 0x04	; 4
    79cc:	f6 94       	lsr	r15
    79ce:	e7 94       	ror	r14
    79d0:	ba 95       	dec	r27
    79d2:	e1 f7       	brne	.-8      	; 0x79cc <main+0x12a>
    79d4:	f0 92 1b 01 	sts	0x011B, r15
    79d8:	e0 92 1a 01 	sts	0x011A, r14
	DataRegionStartSec 			= RootDirRegionStartSec + RootDirRegionSize;	// 528
    79dc:	c8 01       	movw	r24, r16
    79de:	8e 0d       	add	r24, r14
    79e0:	9f 1d       	adc	r25, r15
    79e2:	a0 e0       	ldi	r26, 0x00	; 0
    79e4:	b0 e0       	ldi	r27, 0x00	; 0
    79e6:	80 93 1c 01 	sts	0x011C, r24
    79ea:	90 93 1d 01 	sts	0x011D, r25
    79ee:	a0 93 1e 01 	sts	0x011E, r26
    79f2:	b0 93 1f 01 	sts	0x011F, r27
    79f6:	c0 e0       	ldi	r28, 0x00	; 0
    79f8:	d0 e0       	ldi	r29, 0x00	; 0

	/* fill in the file structure */
	file.startcluster = dir->fstclust;
	file.size = dir->filesize;
	file.sector_counter = 0;
	file.next = buff + 512;
    79fa:	8a ea       	ldi	r24, 0xAA	; 170
    79fc:	c8 2e       	mov	r12, r24
    79fe:	83 e0       	ldi	r24, 0x03	; 3
    7a00:	d8 2e       	mov	r13, r24
static inline uint8_t fat16_readRootDirEntry(uint16_t entry_num,uint16_t *filever) {
	uint8_t direntry_in_sector;
 	direntry_t *dir;
		
	/* Check for end of root dir region reached! */
	if ((entry_num / 16) >= RootDirRegionSize)
    7a02:	ce 01       	movw	r24, r28
    7a04:	a4 e0       	ldi	r26, 0x04	; 4
    7a06:	96 95       	lsr	r25
    7a08:	87 95       	ror	r24
    7a0a:	aa 95       	dec	r26
    7a0c:	e1 f7       	brne	.-8      	; 0x7a06 <main+0x164>
    7a0e:	8e 15       	cp	r24, r14
    7a10:	9f 05       	cpc	r25, r15
    7a12:	08 f0       	brcs	.+2      	; 0x7a16 <main+0x174>
    7a14:	1e c1       	rjmp	.+572    	; 0x7c52 <main+0x3b0>
		return 0;

	/* this finds the sector in which the entry will be saved */	
	uint32_t dirsector = RootDirRegionStartSec + entry_num / 16;
    7a16:	bc 01       	movw	r22, r24
    7a18:	60 0f       	add	r22, r16
    7a1a:	71 1f       	adc	r23, r17
    7a1c:	80 e0       	ldi	r24, 0x00	; 0
    7a1e:	90 e0       	ldi	r25, 0x00	; 0
	/* this is the offset inside the sector */
	/* there are 16 entries in a sector, each 32 bytes long */
    direntry_in_sector = (unsigned char) entry_num % 16;

	/* get the sector into the buffer */
	mmc_start_read_block(dirsector);
    7a20:	0e 94 60 3e 	call	0x7cc0	; 0x7cc0 <mmc_start_read_block>
	
	/* pointer to the direntry inside the buffer */
	dir = (direntry_t *) buff + direntry_in_sector;
    7a24:	ec 2f       	mov	r30, r28
    7a26:	ef 70       	andi	r30, 0x0F	; 15
    7a28:	80 e2       	ldi	r24, 0x20	; 32
    7a2a:	e8 9f       	mul	r30, r24
    7a2c:	f0 01       	movw	r30, r0
    7a2e:	11 24       	eor	r1, r1
    7a30:	e6 55       	subi	r30, 0x56	; 86
    7a32:	fe 4f       	sbci	r31, 0xFE	; 254

	if ((dir->name[0] == 0) || (dir->name[0] == 0xE5) || (dir->fstclust == 0))
    7a34:	80 81       	ld	r24, Z
    7a36:	88 23       	and	r24, r24
    7a38:	09 f4       	brne	.+2      	; 0x7a3c <main+0x19a>
    7a3a:	0b c1       	rjmp	.+534    	; 0x7c52 <main+0x3b0>
    7a3c:	85 3e       	cpi	r24, 0xE5	; 229
    7a3e:	09 f4       	brne	.+2      	; 0x7a42 <main+0x1a0>
    7a40:	08 c1       	rjmp	.+528    	; 0x7c52 <main+0x3b0>
    7a42:	82 8d       	ldd	r24, Z+26	; 0x1a
    7a44:	93 8d       	ldd	r25, Z+27	; 0x1b
    7a46:	00 97       	sbiw	r24, 0x00	; 0
    7a48:	09 f4       	brne	.+2      	; 0x7a4c <main+0x1aa>
    7a4a:	03 c1       	rjmp	.+518    	; 0x7c52 <main+0x3b0>
		return 0;

	/* fill in the file structure */
	file.startcluster = dir->fstclust;
    7a4c:	90 93 0e 01 	sts	0x010E, r25
    7a50:	80 93 0d 01 	sts	0x010D, r24
	file.size = dir->filesize;
    7a54:	84 8d       	ldd	r24, Z+28	; 0x1c
    7a56:	95 8d       	ldd	r25, Z+29	; 0x1d
    7a58:	a6 8d       	ldd	r26, Z+30	; 0x1e
    7a5a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    7a5c:	80 93 11 01 	sts	0x0111, r24
    7a60:	90 93 12 01 	sts	0x0112, r25
    7a64:	a0 93 13 01 	sts	0x0113, r26
    7a68:	b0 93 14 01 	sts	0x0114, r27
	file.sector_counter = 0;
    7a6c:	10 92 10 01 	sts	0x0110, r1
    7a70:	10 92 0f 01 	sts	0x010F, r1
	file.next = buff + 512;
    7a74:	d0 92 16 01 	sts	0x0116, r13
    7a78:	c0 92 15 01 	sts	0x0115, r12

        
	/* compare name */
	uint8_t i = 0;
	uint8_t match = 1;
    7a7c:	31 e0       	ldi	r19, 0x01	; 1
	for (i = 0; nameMatch[i]; i++) { 
    7a7e:	20 e0       	ldi	r18, 0x00	; 0
    7a80:	09 c0       	rjmp	.+18     	; 0x7a94 <main+0x1f2>
	  match &= (nameMatch[i] == dir->name[i]);
    7a82:	da 01       	movw	r26, r20
    7a84:	ae 0f       	add	r26, r30
    7a86:	bf 1f       	adc	r27, r31
    7a88:	91 e0       	ldi	r25, 0x01	; 1
    7a8a:	4c 91       	ld	r20, X
    7a8c:	84 13       	cpse	r24, r20
    7a8e:	90 e0       	ldi	r25, 0x00	; 0
    7a90:	39 23       	and	r19, r25

        
	/* compare name */
	uint8_t i = 0;
	uint8_t match = 1;
	for (i = 0; nameMatch[i]; i++) { 
    7a92:	2f 5f       	subi	r18, 0xFF	; 255
    7a94:	42 2f       	mov	r20, r18
    7a96:	50 e0       	ldi	r21, 0x00	; 0
    7a98:	ca 01       	movw	r24, r20
    7a9a:	8c 5f       	subi	r24, 0xFC	; 252
    7a9c:	9e 4f       	sbci	r25, 0xFE	; 254
    7a9e:	dc 01       	movw	r26, r24
    7aa0:	8c 91       	ld	r24, X
    7aa2:	81 11       	cpse	r24, r1
    7aa4:	ee cf       	rjmp	.-36     	; 0x7a82 <main+0x1e0>
	  match &= (nameMatch[i] == dir->name[i]);
	}
	if (!(match && i)) return 0;
    7aa6:	33 23       	and	r19, r19
    7aa8:	09 f4       	brne	.+2      	; 0x7aac <main+0x20a>
    7aaa:	d3 c0       	rjmp	.+422    	; 0x7c52 <main+0x3b0>
    7aac:	22 23       	and	r18, r18
    7aae:	09 f4       	brne	.+2      	; 0x7ab2 <main+0x210>
    7ab0:	d0 c0       	rjmp	.+416    	; 0x7c52 <main+0x3b0>

        *filever = ((dir->name[i]-'0') << 8) | ((dir->name[i+1]-'0') << 4) | (dir->name[i+2]-'0');
    7ab2:	da 01       	movw	r26, r20
    7ab4:	ae 0f       	add	r26, r30
    7ab6:	bf 1f       	adc	r27, r31
    7ab8:	9c 90       	ld	r9, X
    7aba:	11 96       	adiw	r26, 0x01	; 1
    7abc:	ac 90       	ld	r10, X
    7abe:	11 97       	sbiw	r26, 0x01	; 1
    7ac0:	12 96       	adiw	r26, 0x02	; 2
    7ac2:	bc 90       	ld	r11, X
	
	/* match ending, seach for HEX => return 1, or EEP => return 2*/
	if (dir->name[9] != 'E') return 0;
    7ac4:	81 85       	ldd	r24, Z+9	; 0x09
    7ac6:	85 34       	cpi	r24, 0x45	; 69
    7ac8:	09 f0       	breq	.+2      	; 0x7acc <main+0x22a>
    7aca:	c3 c0       	rjmp	.+390    	; 0x7c52 <main+0x3b0>
	if (dir->name[8] == 'H' && dir->name[10] == 'X') return 1;
    7acc:	80 85       	ldd	r24, Z+8	; 0x08
    7ace:	88 34       	cpi	r24, 0x48	; 72
    7ad0:	29 f4       	brne	.+10     	; 0x7adc <main+0x23a>
    7ad2:	82 85       	ldd	r24, Z+10	; 0x0a
    7ad4:	88 35       	cpi	r24, 0x58	; 88
    7ad6:	09 f0       	breq	.+2      	; 0x7ada <main+0x238>
    7ad8:	bc c0       	rjmp	.+376    	; 0x7c52 <main+0x3b0>
    7ada:	c2 c0       	rjmp	.+388    	; 0x7c60 <main+0x3be>
	if (dir->name[8] == 'E' && dir->name[10] == 'P') return 2;
    7adc:	85 34       	cpi	r24, 0x45	; 69
    7ade:	09 f0       	breq	.+2      	; 0x7ae2 <main+0x240>
    7ae0:	b8 c0       	rjmp	.+368    	; 0x7c52 <main+0x3b0>
    7ae2:	82 85       	ldd	r24, Z+10	; 0x0a
    7ae4:	80 35       	cpi	r24, 0x50	; 80
    7ae6:	09 f0       	breq	.+2      	; 0x7aea <main+0x248>
    7ae8:	b4 c0       	rjmp	.+360    	; 0x7c52 <main+0x3b0>
    7aea:	ad c0       	rjmp	.+346    	; 0x7c46 <main+0x3a4>
    uint8_t num_flash_words = 0;
	uint8_t* out = pagebuffer;
    address = 0;
	while (file.size)
	{
		if (num_flash_words)
    7aec:	ff 20       	and	r15, r15
    7aee:	d1 f0       	breq	.+52     	; 0x7b24 <main+0x282>
		{
			// read (de-hexify)
			*out++ = file_read_hex();
    7af0:	8e 01       	movw	r16, r28
    7af2:	0f 5f       	subi	r16, 0xFF	; 255
    7af4:	1f 4f       	sbci	r17, 0xFF	; 255
    7af6:	0e 94 59 3f 	call	0x7eb2	; 0x7eb2 <file_read_hex>
    7afa:	88 83       	st	Y, r24
			num_flash_words--;
    7afc:	fa 94       	dec	r15
		
			// if pagebuffer is full
			if (out - pagebuffer == SPM_PAGESIZE) {
    7afe:	b1 e0       	ldi	r27, 0x01	; 1
    7b00:	0a 3a       	cpi	r16, 0xAA	; 170
    7b02:	1b 07       	cpc	r17, r27
    7b04:	41 f5       	brne	.+80     	; 0x7b56 <main+0x2b4>
			    // write page
#ifdef BOOT_LOADER
			    write_flash_page();
    7b06:	0e 94 7a 3f 	call	0x7ef4	; 0x7ef4 <write_flash_page>
#endif
			    address += SPM_PAGESIZE;
    7b0a:	20 91 28 01 	lds	r18, 0x0128
    7b0e:	30 91 29 01 	lds	r19, 0x0129
    7b12:	20 58       	subi	r18, 0x80	; 128
    7b14:	3f 4f       	sbci	r19, 0xFF	; 255
    7b16:	30 93 29 01 	sts	0x0129, r19
    7b1a:	20 93 28 01 	sts	0x0128, r18
				out = pagebuffer;
    7b1e:	ca e2       	ldi	r28, 0x2A	; 42
    7b20:	d1 e0       	ldi	r29, 0x01	; 1
    7b22:	1a c0       	rjmp	.+52     	; 0x7b58 <main+0x2b6>
			}
		} 
		else
		{
			// skip bytes until we find another ':'
			if (file_read_byte() == ':') {
    7b24:	0e 94 b9 3e 	call	0x7d72	; 0x7d72 <file_read_byte>
    7b28:	8a 33       	cpi	r24, 0x3A	; 58
    7b2a:	b1 f4       	brne	.+44     	; 0x7b58 <main+0x2b6>
				num_flash_words = file_read_hex();
    7b2c:	0e 94 59 3f 	call	0x7eb2	; 0x7eb2 <file_read_hex>
    7b30:	f8 2e       	mov	r15, r24
				file.next+=4; /* skip 4 bytes, address */
    7b32:	20 91 15 01 	lds	r18, 0x0115
    7b36:	30 91 16 01 	lds	r19, 0x0116
    7b3a:	2c 5f       	subi	r18, 0xFC	; 252
    7b3c:	3f 4f       	sbci	r19, 0xFF	; 255
    7b3e:	30 93 16 01 	sts	0x0116, r19
    7b42:	20 93 15 01 	sts	0x0115, r18
				if (file_read_hex()==1) break; //01 is EOF
    7b46:	0e 94 59 3f 	call	0x7eb2	; 0x7eb2 <file_read_hex>
    7b4a:	81 30       	cpi	r24, 0x01	; 1
    7b4c:	29 f4       	brne	.+10     	; 0x7b58 <main+0x2b6>
			}
		}
	}
#ifdef BOOT_LOADER
	if (out != pagebuffer) write_flash_page();
    7b4e:	ca 52       	subi	r28, 0x2A	; 42
    7b50:	d1 40       	sbci	r29, 0x01	; 1
    7b52:	81 f4       	brne	.+32     	; 0x7b74 <main+0x2d2>
    7b54:	11 c0       	rjmp	.+34     	; 0x7b78 <main+0x2d6>
	while (file.size)
	{
		if (num_flash_words)
		{
			// read (de-hexify)
			*out++ = file_read_hex();
    7b56:	e8 01       	movw	r28, r16
static inline void read_hex_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
	uint8_t* out = pagebuffer;
    address = 0;
	while (file.size)
    7b58:	40 91 11 01 	lds	r20, 0x0111
    7b5c:	50 91 12 01 	lds	r21, 0x0112
    7b60:	60 91 13 01 	lds	r22, 0x0113
    7b64:	70 91 14 01 	lds	r23, 0x0114
    7b68:	45 2b       	or	r20, r21
    7b6a:	46 2b       	or	r20, r22
    7b6c:	47 2b       	or	r20, r23
    7b6e:	09 f0       	breq	.+2      	; 0x7b72 <main+0x2d0>
    7b70:	bd cf       	rjmp	.-134    	; 0x7aec <main+0x24a>
    7b72:	ed cf       	rjmp	.-38     	; 0x7b4e <main+0x2ac>
				if (file_read_hex()==1) break; //01 is EOF
			}
		}
	}
#ifdef BOOT_LOADER
	if (out != pagebuffer) write_flash_page();
    7b74:	0e 94 7a 3f 	call	0x7ef4	; 0x7ef4 <write_flash_page>
	for (i = 0; nameMatch[i]; i++) { 
	  match &= (nameMatch[i] == dir->name[i]);
	}
	if (!(match && i)) return 0;

        *filever = ((dir->name[i]-'0') << 8) | ((dir->name[i+1]-'0') << 4) | (dir->name[i+2]-'0');
    7b78:	69 2d       	mov	r22, r9
    7b7a:	70 e0       	ldi	r23, 0x00	; 0
    7b7c:	60 53       	subi	r22, 0x30	; 48
    7b7e:	71 09       	sbc	r23, r1
    7b80:	76 2f       	mov	r23, r22
    7b82:	66 27       	eor	r22, r22
    7b84:	8a 2d       	mov	r24, r10
    7b86:	90 e0       	ldi	r25, 0x00	; 0
    7b88:	c0 97       	sbiw	r24, 0x30	; 48
    7b8a:	f4 e0       	ldi	r31, 0x04	; 4
    7b8c:	88 0f       	add	r24, r24
    7b8e:	99 1f       	adc	r25, r25
    7b90:	fa 95       	dec	r31
    7b92:	e1 f7       	brne	.-8      	; 0x7b8c <main+0x2ea>
    7b94:	68 2b       	or	r22, r24
    7b96:	79 2b       	or	r23, r25
    7b98:	8b 2d       	mov	r24, r11
    7b9a:	90 e0       	ldi	r25, 0x00	; 0
    7b9c:	c0 97       	sbiw	r24, 0x30	; 48
    7b9e:	68 2b       	or	r22, r24
    7ba0:	79 2b       	or	r23, r25
           //We are in progress write flash, busy bit
           eeprom_update_word((uint16_t *)E2END - 1, 0xFFFF);
           //Read the hex file
           read_hex_file();
            //We are ready write flash, file version
           eeprom_update_word((uint16_t *)E2END - 1, filever);
    7ba2:	8d ef       	ldi	r24, 0xFD	; 253
    7ba4:	93 e0       	ldi	r25, 0x03	; 3
    7ba6:	0e 94 ba 3f 	call	0x7f74	; 0x7f74 <__eeupd_word_m328p>
           #ifdef UART_DEBUG
             UART_putsP(PSTR("finish="),filever);
           #endif
           break;
    7baa:	3a c0       	rjmp	.+116    	; 0x7c20 <main+0x37e>
static inline void read_eep_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
    address = 0;
    while (file.size) {
	if (num_flash_words) {
    7bac:	cc 23       	and	r28, r28
    7bae:	99 f0       	breq	.+38     	; 0x7bd6 <main+0x334>
             eeprom_update_byte((uint8_t *)address++, file_read_hex());
    7bb0:	0e 94 59 3f 	call	0x7eb2	; 0x7eb2 <file_read_hex>
    7bb4:	20 91 28 01 	lds	r18, 0x0128
    7bb8:	30 91 29 01 	lds	r19, 0x0129
    7bbc:	a9 01       	movw	r20, r18
    7bbe:	4f 5f       	subi	r20, 0xFF	; 255
    7bc0:	5f 4f       	sbci	r21, 0xFF	; 255
    7bc2:	50 93 29 01 	sts	0x0129, r21
    7bc6:	40 93 28 01 	sts	0x0128, r20
    7bca:	68 2f       	mov	r22, r24
    7bcc:	c9 01       	movw	r24, r18
    7bce:	0e 94 a8 3f 	call	0x7f50	; 0x7f50 <__eeupd_byte_m328p>
	     num_flash_words--;
    7bd2:	c1 50       	subi	r28, 0x01	; 1
    7bd4:	19 c0       	rjmp	.+50     	; 0x7c08 <main+0x366>
         } else {
	  // skip bytes until we find another ':'
	  if (file_read_byte() == ':') {
    7bd6:	0e 94 b9 3e 	call	0x7d72	; 0x7d72 <file_read_byte>
    7bda:	8a 33       	cpi	r24, 0x3A	; 58
    7bdc:	a9 f4       	brne	.+42     	; 0x7c08 <main+0x366>
            num_flash_words = file_read_hex();
    7bde:	0e 94 59 3f 	call	0x7eb2	; 0x7eb2 <file_read_hex>
    7be2:	c8 2f       	mov	r28, r24
	    address=file_read_hex()<<8 | file_read_hex(); /* Read new address */
    7be4:	0e 94 59 3f 	call	0x7eb2	; 0x7eb2 <file_read_hex>
    7be8:	d8 2f       	mov	r29, r24
    7bea:	0e 94 59 3f 	call	0x7eb2	; 0x7eb2 <file_read_hex>
    7bee:	2d 2f       	mov	r18, r29
    7bf0:	30 e0       	ldi	r19, 0x00	; 0
    7bf2:	32 2f       	mov	r19, r18
    7bf4:	22 27       	eor	r18, r18
    7bf6:	28 2b       	or	r18, r24
    7bf8:	30 93 29 01 	sts	0x0129, r19
    7bfc:	20 93 28 01 	sts	0x0128, r18
            if (file_read_hex()==1) break;
    7c00:	0e 94 59 3f 	call	0x7eb2	; 0x7eb2 <file_read_hex>
    7c04:	81 30       	cpi	r24, 0x01	; 1
    7c06:	61 f0       	breq	.+24     	; 0x7c20 <main+0x37e>

static inline void read_eep_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
    address = 0;
    while (file.size) {
    7c08:	40 91 11 01 	lds	r20, 0x0111
    7c0c:	50 91 12 01 	lds	r21, 0x0112
    7c10:	60 91 13 01 	lds	r22, 0x0113
    7c14:	70 91 14 01 	lds	r23, 0x0114
    7c18:	45 2b       	or	r20, r21
    7c1a:	46 2b       	or	r20, r22
    7c1c:	47 2b       	or	r20, r23
    7c1e:	31 f6       	brne	.-116    	; 0x7bac <main+0x30a>
     UART_putsP(PSTR("REBOOT="),filever);
  #endif

#ifdef BOOT_LOADER
	/* we reset via watchdog in order to reset all the registers to their default values */
	WDTCSR = _BV(WDE);
    7c20:	88 e0       	ldi	r24, 0x08	; 8
    7c22:	80 93 60 00 	sts	0x0060, r24
    7c26:	ff cf       	rjmp	.-2      	; 0x7c26 <main+0x384>
	if(i==MMC_CMD0_RETRY) return(MMC_TIMEOUT);

	if (res != 0x01) //Response R1 from MMC (0x01: IDLE, The card is in idle state and running the initializing process.)
		return(MMC_INIT);
	
	cmd[0]=0x40 + MMC_SEND_OP_COND;
    7c28:	81 e4       	ldi	r24, 0x41	; 65
    7c2a:	80 93 22 01 	sts	0x0122, r24
    7c2e:	80 ce       	rjmp	.-768    	; 0x7930 <main+0x8e>
	mbr_t *mbr = (mbr_t*) buff;
	vbr_t *vbr = (vbr_t*) buff;
		
	if (mmc_init() != MMC_OK) return 1;
	
    mmc_start_read_block(0);
    7c30:	60 e0       	ldi	r22, 0x00	; 0
    7c32:	70 e0       	ldi	r23, 0x00	; 0
    7c34:	cb 01       	movw	r24, r22
    7c36:	0e 94 60 3e 	call	0x7cc0	; 0x7cc0 <mmc_start_read_block>

    // Try sector 0 as a bootsector
	if ((vbr->bsFileSysType[0] == 'F') && (vbr->bsFileSysType[4] == '6'))
    7c3a:	80 91 e0 01 	lds	r24, 0x01E0
    7c3e:	86 34       	cpi	r24, 0x46	; 70
    7c40:	09 f0       	breq	.+2      	; 0x7c44 <main+0x3a2>
    7c42:	84 ce       	rjmp	.-760    	; 0x794c <main+0xaa>
    7c44:	7a ce       	rjmp	.-780    	; 0x793a <main+0x98>
}

static inline void read_eep_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
    address = 0;
    7c46:	10 92 29 01 	sts	0x0129, r1
    7c4a:	10 92 28 01 	sts	0x0128, r1
#endif
}

static inline void read_eep_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
    7c4e:	c0 e0       	ldi	r28, 0x00	; 0
    7c50:	db cf       	rjmp	.-74     	; 0x7c08 <main+0x366>

     #ifdef UART_DEBUG
       UART_putsP(PSTR("SD="),1);
    #endif
     /* for each file in ROOT... */
     for (uint16_t entrycounter=0; entrycounter<512; entrycounter++){
    7c52:	21 96       	adiw	r28, 0x01	; 1
    7c54:	c1 15       	cp	r28, r1
    7c56:	a2 e0       	ldi	r26, 0x02	; 2
    7c58:	da 07       	cpc	r29, r26
    7c5a:	09 f0       	breq	.+2      	; 0x7c5e <main+0x3bc>
    7c5c:	d2 ce       	rjmp	.-604    	; 0x7a02 <main+0x160>
    7c5e:	e0 cf       	rjmp	.-64     	; 0x7c20 <main+0x37e>
            #ifdef UART_DEBUG
              UART_putsP(PSTR("start="),flashver);
            #endif

           //We are in progress write flash, busy bit
           eeprom_update_word((uint16_t *)E2END - 1, 0xFFFF);
    7c60:	6f ef       	ldi	r22, 0xFF	; 255
    7c62:	7f ef       	ldi	r23, 0xFF	; 255
    7c64:	8d ef       	ldi	r24, 0xFD	; 253
    7c66:	93 e0       	ldi	r25, 0x03	; 3
    7c68:	0e 94 ba 3f 	call	0x7f74	; 0x7f74 <__eeupd_word_m328p>

static inline void read_hex_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
	uint8_t* out = pagebuffer;
    address = 0;
    7c6c:	10 92 29 01 	sts	0x0129, r1
    7c70:	10 92 28 01 	sts	0x0128, r1
}

static inline void read_hex_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
	uint8_t* out = pagebuffer;
    7c74:	ca e2       	ldi	r28, 0x2A	; 42
    7c76:	d1 e0       	ldi	r29, 0x01	; 1
	return (gethexnib(file_read_byte()) << 4) + gethexnib(file_read_byte());
}

static inline void read_hex_file(void) {
	// read file and convert it from intel hex and flash it
    uint8_t num_flash_words = 0;
    7c78:	f1 2c       	mov	r15, r1
    7c7a:	6e cf       	rjmp	.-292    	; 0x7b58 <main+0x2b6>

00007c7c <__bad_interrupt>:
    7c7c:	0c 94 00 3c 	jmp	0x7800	; 0x7800 <__vectors>

00007c80 <spi_send_byte>:

/* ---[ SPI Interface ]---------------------------------------------- */

static void spi_send_byte(unsigned char data)
{
	SPDR=data;
    7c80:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF); // wait for byte transmitted...
    7c82:	0d b4       	in	r0, 0x2d	; 45
    7c84:	07 fe       	sbrs	r0, 7
    7c86:	fd cf       	rjmp	.-6      	; 0x7c82 <spi_send_byte+0x2>
}
    7c88:	08 95       	ret

00007c8a <send_cmd>:

static unsigned char send_cmd(void)
{
    7c8a:	cf 93       	push	r28
    7c8c:	df 93       	push	r29
	unsigned char i;
	unsigned char *buf;
	
  	spi_send_byte(0xFF);      //Dummy delay 8 clocks
    7c8e:	8f ef       	ldi	r24, 0xFF	; 255
    7c90:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
	MMC_PORT &= ~(1<<MMC_CS); //MMC Chip Select -> Low (activate mmc)
    7c94:	2a 98       	cbi	0x05, 2	; 5
    7c96:	c2 e2       	ldi	r28, 0x22	; 34
    7c98:	d1 e0       	ldi	r29, 0x01	; 1

	/* send the 6 cmd bytes */
	i=6;
	buf = cmd;
	while(i) {
		spi_send_byte(*buf++);
    7c9a:	89 91       	ld	r24, Y+
    7c9c:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
	MMC_PORT &= ~(1<<MMC_CS); //MMC Chip Select -> Low (activate mmc)

	/* send the 6 cmd bytes */
	i=6;
	buf = cmd;
	while(i) {
    7ca0:	81 e0       	ldi	r24, 0x01	; 1
    7ca2:	c8 32       	cpi	r28, 0x28	; 40
    7ca4:	d8 07       	cpc	r29, r24
    7ca6:	c9 f7       	brne	.-14     	; 0x7c9a <send_cmd+0x10>
    7ca8:	cf ef       	ldi	r28, 0xFF	; 255
	unsigned char result;
	
	/* wait for response */
	for(i=0; i<255; i++) {
	
 		spi_send_byte(0xFF);
    7caa:	8f ef       	ldi	r24, 0xFF	; 255
    7cac:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
		result = SPDR;
    7cb0:	8e b5       	in	r24, 0x2e	; 46
		
		if ((result & 0x80) == 0)
    7cb2:	87 ff       	sbrs	r24, 7
    7cb4:	02 c0       	rjmp	.+4      	; 0x7cba <send_cmd+0x30>
    7cb6:	c1 50       	subi	r28, 0x01	; 1
	}

	unsigned char result;
	
	/* wait for response */
	for(i=0; i<255; i++) {
    7cb8:	c1 f7       	brne	.-16     	; 0x7caa <send_cmd+0x20>
		if ((result & 0x80) == 0)
			break;
	}

	return(result); // TimeOut !?
}
    7cba:	df 91       	pop	r29
    7cbc:	cf 91       	pop	r28
    7cbe:	08 95       	ret

00007cc0 <mmc_start_read_block>:
 *			MMC_OK:						Command successful
 *			MMC_CMDERROR:			Error while sending read command to mmc
 *			MMC_NOSTARTBYTE:	No start byte received
 */
static unsigned char mmc_start_read_block(unsigned long adr)
{
    7cc0:	0f 93       	push	r16
    7cc2:	1f 93       	push	r17
    7cc4:	cf 93       	push	r28
    7cc6:	df 93       	push	r29
	if (adr==lastAdr) return (MMC_OK);
    7cc8:	00 91 00 01 	lds	r16, 0x0100
    7ccc:	10 91 01 01 	lds	r17, 0x0101
    7cd0:	20 91 02 01 	lds	r18, 0x0102
    7cd4:	30 91 03 01 	lds	r19, 0x0103
    7cd8:	60 17       	cp	r22, r16
    7cda:	71 07       	cpc	r23, r17
    7cdc:	82 07       	cpc	r24, r18
    7cde:	93 07       	cpc	r25, r19
    7ce0:	09 f4       	brne	.+2      	; 0x7ce4 <mmc_start_read_block+0x24>
    7ce2:	40 c0       	rjmp	.+128    	; 0x7d64 <mmc_start_read_block+0xa4>
        lastAdr = adr;
    7ce4:	60 93 00 01 	sts	0x0100, r22
    7ce8:	70 93 01 01 	sts	0x0101, r23
    7cec:	80 93 02 01 	sts	0x0102, r24
    7cf0:	90 93 03 01 	sts	0x0103, r25
        adr <<= 1;
    7cf4:	dc 01       	movw	r26, r24
    7cf6:	cb 01       	movw	r24, r22
    7cf8:	88 0f       	add	r24, r24
    7cfa:	99 1f       	adc	r25, r25
    7cfc:	aa 1f       	adc	r26, r26
    7cfe:	bb 1f       	adc	r27, r27
	
	cmd[0] = 0x40 + MMC_READ_SINGLE_BLOCK;
    7d00:	21 e5       	ldi	r18, 0x51	; 81
    7d02:	20 93 22 01 	sts	0x0122, r18
	cmd[1] = (adr & 0x00FF0000) >> 0x10;
    7d06:	a0 93 23 01 	sts	0x0123, r26
	cmd[2] = (adr & 0x0000FF00) >> 0x08;
    7d0a:	90 93 24 01 	sts	0x0124, r25
	cmd[3] = (adr & 0x000000FF);
    7d0e:	80 93 25 01 	sts	0x0125, r24
	cmd[4] = 0;
    7d12:	10 92 26 01 	sts	0x0126, r1

	SPCR = 1<<SPE | 1<<MSTR | SPI_READ_CLOCK; //SPI Enable, SPI Master Mode
    7d16:	80 e5       	ldi	r24, 0x50	; 80
    7d18:	8c bd       	out	0x2c, r24	; 44
	
	if (send_cmd() != 0x00 || wait_start_byte()) {
    7d1a:	0e 94 45 3e 	call	0x7c8a	; 0x7c8a <send_cmd>
    7d1e:	18 2f       	mov	r17, r24
    7d20:	88 23       	and	r24, r24
    7d22:	19 f0       	breq	.+6      	; 0x7d2a <mmc_start_read_block+0x6a>
		MMC_PORT |= 1<<MMC_CS; //MMC Chip Select -> High (deactivate mmc);
    7d24:	2a 9a       	sbi	0x05, 2	; 5
		return(MMC_CMDERROR); //wrong response!
    7d26:	13 e0       	ldi	r17, 0x03	; 3
    7d28:	1e c0       	rjmp	.+60     	; 0x7d66 <mmc_start_read_block+0xa6>
	cmd[3] = (adr & 0x000000FF);
	cmd[4] = 0;

	SPCR = 1<<SPE | 1<<MSTR | SPI_READ_CLOCK; //SPI Enable, SPI Master Mode
	
	if (send_cmd() != 0x00 || wait_start_byte()) {
    7d2a:	cf ef       	ldi	r28, 0xFF	; 255
{
	unsigned char i;
	
	i=255;
	do {
		spi_send_byte(0xFF);
    7d2c:	8f ef       	ldi	r24, 0xFF	; 255
    7d2e:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
		if(SPDR == 0xFE) return MMC_OK;
    7d32:	8e b5       	in	r24, 0x2e	; 46
    7d34:	8e 3f       	cpi	r24, 0xFE	; 254
    7d36:	19 f0       	breq	.+6      	; 0x7d3e <mmc_start_read_block+0x7e>
    7d38:	c1 50       	subi	r28, 0x01	; 1
	} while(--i);
    7d3a:	c1 f7       	brne	.-16     	; 0x7d2c <mmc_start_read_block+0x6c>
    7d3c:	f3 cf       	rjmp	.-26     	; 0x7d24 <mmc_start_read_block+0x64>
    7d3e:	ca ea       	ldi	r28, 0xAA	; 170
    7d40:	d1 e0       	ldi	r29, 0x01	; 1
 
	buf = buff;
	len= 512;
	
	while (len) {
		spi_send_byte(0xFF);
    7d42:	8f ef       	ldi	r24, 0xFF	; 255
    7d44:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
		*buf++ = SPDR;
    7d48:	8e b5       	in	r24, 0x2e	; 46
    7d4a:	89 93       	st	Y+, r24
	unsigned short len;
 
	buf = buff;
	len= 512;
	
	while (len) {
    7d4c:	83 e0       	ldi	r24, 0x03	; 3
    7d4e:	ca 3a       	cpi	r28, 0xAA	; 170
    7d50:	d8 07       	cpc	r29, r24
    7d52:	b9 f7       	brne	.-18     	; 0x7d42 <mmc_start_read_block+0x82>
		len--;
	}
	
	//mmc_stop_read_block
	//read 2 bytes CRC (not used);
	spi_send_byte(0xFF);
    7d54:	8f ef       	ldi	r24, 0xFF	; 255
    7d56:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
	spi_send_byte(0xFF);
    7d5a:	8f ef       	ldi	r24, 0xFF	; 255
    7d5c:	0e 94 40 3e 	call	0x7c80	; 0x7c80 <spi_send_byte>
	MMC_PORT |= 1<<MMC_CS; //MMC Chip Select -> High (deactivate mmc);
    7d60:	2a 9a       	sbi	0x05, 2	; 5
	
        #ifdef UART_DEBUG
          UART_dumpsector(buff);
        #endif   
     return(MMC_OK);
    7d62:	01 c0       	rjmp	.+2      	; 0x7d66 <mmc_start_read_block+0xa6>
 *			MMC_CMDERROR:			Error while sending read command to mmc
 *			MMC_NOSTARTBYTE:	No start byte received
 */
static unsigned char mmc_start_read_block(unsigned long adr)
{
	if (adr==lastAdr) return (MMC_OK);
    7d64:	10 e0       	ldi	r17, 0x00	; 0
	
        #ifdef UART_DEBUG
          UART_dumpsector(buff);
        #endif   
     return(MMC_OK);
}
    7d66:	81 2f       	mov	r24, r17
    7d68:	df 91       	pop	r29
    7d6a:	cf 91       	pop	r28
    7d6c:	1f 91       	pop	r17
    7d6e:	0f 91       	pop	r16
    7d70:	08 95       	ret

00007d72 <file_read_byte>:
	file.sector_counter++;
}

/* ----[ file ]--------------------------------------------------- */

static uint8_t file_read_byte() {	// read a byte from the open file from the mmc...
    7d72:	8f 92       	push	r8
    7d74:	9f 92       	push	r9
    7d76:	af 92       	push	r10
    7d78:	bf 92       	push	r11
    7d7a:	cf 92       	push	r12
    7d7c:	df 92       	push	r13
    7d7e:	ef 92       	push	r14
    7d80:	ff 92       	push	r15
    7d82:	0f 93       	push	r16
    7d84:	1f 93       	push	r17
    7d86:	cf 93       	push	r28
    7d88:	df 93       	push	r29
	if (file.next >= buff + 512) {
    7d8a:	00 91 15 01 	lds	r16, 0x0115
    7d8e:	10 91 16 01 	lds	r17, 0x0116
    7d92:	83 e0       	ldi	r24, 0x03	; 3
    7d94:	0a 3a       	cpi	r16, 0xAA	; 170
    7d96:	18 07       	cpc	r17, r24
    7d98:	08 f4       	brcc	.+2      	; 0x7d9c <file_read_byte+0x2a>
    7d9a:	60 c0       	rjmp	.+192    	; 0x7e5c <file_read_byte+0xea>
{
	uint16_t clusteroffset;
	uint8_t currentfatsector;
	uint8_t temp, secoffset;
	uint32_t templong;
	uint16_t cluster = file.startcluster;
    7d9c:	e0 90 0d 01 	lds	r14, 0x010D
    7da0:	f0 90 0e 01 	lds	r15, 0x010E
	
	fatsector_t *fatsector = (fatsector_t*) buff;

	/* SectorsPerCluster is always power of 2 ! */
	secoffset = (uint8_t)file.sector_counter & (SectorsPerCluster-1);
    7da4:	c0 91 0f 01 	lds	r28, 0x010F
    7da8:	d0 91 10 01 	lds	r29, 0x0110
    7dac:	80 90 19 01 	lds	r8, 0x0119
    7db0:	99 24       	eor	r9, r9
    7db2:	9a 94       	dec	r9
    7db4:	98 0c       	add	r9, r8
    7db6:	9c 22       	and	r9, r28
	
	clusteroffset = file.sector_counter;
	temp = SectorsPerCluster >> 1;
    7db8:	86 94       	lsr	r8
    7dba:	88 2d       	mov	r24, r8
	fatsector_t *fatsector = (fatsector_t*) buff;

	/* SectorsPerCluster is always power of 2 ! */
	secoffset = (uint8_t)file.sector_counter & (SectorsPerCluster-1);
	
	clusteroffset = file.sector_counter;
    7dbc:	6e 01       	movw	r12, r28
	temp = SectorsPerCluster >> 1;
	while(temp) {
    7dbe:	88 23       	and	r24, r24
    7dc0:	21 f0       	breq	.+8      	; 0x7dca <file_read_byte+0x58>
		clusteroffset >>= 1;
    7dc2:	d6 94       	lsr	r13
    7dc4:	c7 94       	ror	r12
        temp >>= 1;
    7dc6:	86 95       	lsr	r24
    7dc8:	fa cf       	rjmp	.-12     	; 0x7dbe <file_read_byte+0x4c>
	/* SectorsPerCluster is always power of 2 ! */
	secoffset = (uint8_t)file.sector_counter & (SectorsPerCluster-1);
	
	clusteroffset = file.sector_counter;
	temp = SectorsPerCluster >> 1;
	while(temp) {
    7dca:	8f ef       	ldi	r24, 0xFF	; 255
		clusteroffset >>= 1;
        temp >>= 1;
    }

	currentfatsector = 0xFF;
	while (clusteroffset)
    7dcc:	c1 14       	cp	r12, r1
    7dce:	d1 04       	cpc	r13, r1
    7dd0:	d9 f0       	breq	.+54     	; 0x7e08 <file_read_byte+0x96>
	{
		temp = (unsigned char)((cluster & 0xFF00) >>8);
    7dd2:	af 2c       	mov	r10, r15
    7dd4:	bb 24       	eor	r11, r11
          
		if (currentfatsector != temp)
    7dd6:	8a 15       	cp	r24, r10
    7dd8:	51 f0       	breq	.+20     	; 0x7dee <file_read_byte+0x7c>
		{
			mmc_start_read_block(FATRegionStartSec + temp);
    7dda:	60 91 17 01 	lds	r22, 0x0117
    7dde:	70 91 18 01 	lds	r23, 0x0118
    7de2:	6a 0d       	add	r22, r10
    7de4:	7b 1d       	adc	r23, r11
    7de6:	80 e0       	ldi	r24, 0x00	; 0
    7de8:	90 e0       	ldi	r25, 0x00	; 0
    7dea:	0e 94 60 3e 	call	0x7cc0	; 0x7cc0 <mmc_start_read_block>

			currentfatsector = temp;
		}
		
		cluster = fatsector->fat_entry[cluster % 256];
    7dee:	f7 01       	movw	r30, r14
    7df0:	ff 27       	eor	r31, r31
    7df2:	ee 0f       	add	r30, r30
    7df4:	ff 1f       	adc	r31, r31
    7df6:	e6 55       	subi	r30, 0x56	; 86
    7df8:	fe 4f       	sbci	r31, 0xFE	; 254
    7dfa:	e0 80       	ld	r14, Z
    7dfc:	f1 80       	ldd	r15, Z+1	; 0x01
		clusteroffset--;
    7dfe:	81 e0       	ldi	r24, 0x01	; 1
    7e00:	c8 1a       	sub	r12, r24
    7e02:	d1 08       	sbc	r13, r1
    7e04:	8a 2d       	mov	r24, r10
    7e06:	e2 cf       	rjmp	.-60     	; 0x7dcc <file_read_byte+0x5a>
	}

	templong = cluster - 2;
    7e08:	67 01       	movw	r12, r14
    7e0a:	82 e0       	ldi	r24, 0x02	; 2
    7e0c:	c8 1a       	sub	r12, r24
    7e0e:	d1 08       	sbc	r13, r1
    7e10:	e1 2c       	mov	r14, r1
    7e12:	f1 2c       	mov	r15, r1
	temp = SectorsPerCluster>>1;
	while(temp) {
    7e14:	88 20       	and	r8, r8
    7e16:	31 f0       	breq	.+12     	; 0x7e24 <file_read_byte+0xb2>
		templong <<= 1;	
    7e18:	cc 0c       	add	r12, r12
    7e1a:	dd 1c       	adc	r13, r13
    7e1c:	ee 1c       	adc	r14, r14
    7e1e:	ff 1c       	adc	r15, r15
		temp >>= 1;
    7e20:	86 94       	lsr	r8
    7e22:	f8 cf       	rjmp	.-16     	; 0x7e14 <file_read_byte+0xa2>
	}
		
	/* read the sector of the file into the buffer */
	mmc_start_read_block(templong + DataRegionStartSec + secoffset);
    7e24:	60 91 1c 01 	lds	r22, 0x011C
    7e28:	70 91 1d 01 	lds	r23, 0x011D
    7e2c:	80 91 1e 01 	lds	r24, 0x011E
    7e30:	90 91 1f 01 	lds	r25, 0x011F
    7e34:	69 0d       	add	r22, r9
    7e36:	71 1d       	adc	r23, r1
    7e38:	81 1d       	adc	r24, r1
    7e3a:	91 1d       	adc	r25, r1
    7e3c:	6c 0d       	add	r22, r12
    7e3e:	7d 1d       	adc	r23, r13
    7e40:	8e 1d       	adc	r24, r14
    7e42:	9f 1d       	adc	r25, r15
    7e44:	0e 94 60 3e 	call	0x7cc0	; 0x7cc0 <mmc_start_read_block>
	
	/* advance to next sector */
	file.sector_counter++;
    7e48:	21 96       	adiw	r28, 0x01	; 1
    7e4a:	d0 93 10 01 	sts	0x0110, r29
    7e4e:	c0 93 0f 01 	sts	0x010F, r28
/* ----[ file ]--------------------------------------------------- */

static uint8_t file_read_byte() {	// read a byte from the open file from the mmc...
	if (file.next >= buff + 512) {
	    fat16_readfilesector();
		file.next = file.next - 512;
    7e52:	12 50       	subi	r17, 0x02	; 2
    7e54:	10 93 16 01 	sts	0x0116, r17
    7e58:	00 93 15 01 	sts	0x0115, r16
	}
	file.size--;
    7e5c:	80 91 11 01 	lds	r24, 0x0111
    7e60:	90 91 12 01 	lds	r25, 0x0112
    7e64:	a0 91 13 01 	lds	r26, 0x0113
    7e68:	b0 91 14 01 	lds	r27, 0x0114
    7e6c:	01 97       	sbiw	r24, 0x01	; 1
    7e6e:	a1 09       	sbc	r26, r1
    7e70:	b1 09       	sbc	r27, r1
    7e72:	80 93 11 01 	sts	0x0111, r24
    7e76:	90 93 12 01 	sts	0x0112, r25
    7e7a:	a0 93 13 01 	sts	0x0113, r26
    7e7e:	b0 93 14 01 	sts	0x0114, r27
	return *file.next++;
    7e82:	e0 91 15 01 	lds	r30, 0x0115
    7e86:	f0 91 16 01 	lds	r31, 0x0116
    7e8a:	cf 01       	movw	r24, r30
    7e8c:	01 96       	adiw	r24, 0x01	; 1
    7e8e:	90 93 16 01 	sts	0x0116, r25
    7e92:	80 93 15 01 	sts	0x0115, r24
}
    7e96:	80 81       	ld	r24, Z
    7e98:	df 91       	pop	r29
    7e9a:	cf 91       	pop	r28
    7e9c:	1f 91       	pop	r17
    7e9e:	0f 91       	pop	r16
    7ea0:	ff 90       	pop	r15
    7ea2:	ef 90       	pop	r14
    7ea4:	df 90       	pop	r13
    7ea6:	cf 90       	pop	r12
    7ea8:	bf 90       	pop	r11
    7eaa:	af 90       	pop	r10
    7eac:	9f 90       	pop	r9
    7eae:	8f 90       	pop	r8
    7eb0:	08 95       	ret

00007eb2 <file_read_hex>:
		return(a - '0');
	}
	return a;
}

static uint8_t file_read_hex(void) {
    7eb2:	cf 93       	push	r28
	return (gethexnib(file_read_byte()) << 4) + gethexnib(file_read_byte());
    7eb4:	0e 94 b9 3e 	call	0x7d72	; 0x7d72 <file_read_byte>
	file.size--;
	return *file.next++;
}

static char gethexnib(char a) {
	if(a >= 'a') {
    7eb8:	81 36       	cpi	r24, 0x61	; 97
    7eba:	10 f0       	brcs	.+4      	; 0x7ec0 <file_read_hex+0xe>
		return (a - 'a' + 0x0a);
    7ebc:	87 55       	subi	r24, 0x57	; 87
    7ebe:	07 c0       	rjmp	.+14     	; 0x7ece <file_read_hex+0x1c>
	} else if(a >= 'A') {
    7ec0:	81 34       	cpi	r24, 0x41	; 65
    7ec2:	10 f0       	brcs	.+4      	; 0x7ec8 <file_read_hex+0x16>
		return (a - 'A' + 0x0a);
    7ec4:	87 53       	subi	r24, 0x37	; 55
    7ec6:	03 c0       	rjmp	.+6      	; 0x7ece <file_read_hex+0x1c>
	} else if(a >= '0') {
    7ec8:	80 33       	cpi	r24, 0x30	; 48
    7eca:	08 f0       	brcs	.+2      	; 0x7ece <file_read_hex+0x1c>
		return(a - '0');
    7ecc:	80 53       	subi	r24, 0x30	; 48
	}
	return a;
}

static uint8_t file_read_hex(void) {
	return (gethexnib(file_read_byte()) << 4) + gethexnib(file_read_byte());
    7ece:	c8 2f       	mov	r28, r24
    7ed0:	c2 95       	swap	r28
    7ed2:	c0 7f       	andi	r28, 0xF0	; 240
    7ed4:	0e 94 b9 3e 	call	0x7d72	; 0x7d72 <file_read_byte>
	file.size--;
	return *file.next++;
}

static char gethexnib(char a) {
	if(a >= 'a') {
    7ed8:	81 36       	cpi	r24, 0x61	; 97
    7eda:	10 f0       	brcs	.+4      	; 0x7ee0 <file_read_hex+0x2e>
		return (a - 'a' + 0x0a);
    7edc:	87 55       	subi	r24, 0x57	; 87
    7ede:	07 c0       	rjmp	.+14     	; 0x7eee <file_read_hex+0x3c>
	} else if(a >= 'A') {
    7ee0:	81 34       	cpi	r24, 0x41	; 65
    7ee2:	10 f0       	brcs	.+4      	; 0x7ee8 <file_read_hex+0x36>
		return (a - 'A' + 0x0a);
    7ee4:	87 53       	subi	r24, 0x37	; 55
    7ee6:	03 c0       	rjmp	.+6      	; 0x7eee <file_read_hex+0x3c>
	} else if(a >= '0') {
    7ee8:	80 33       	cpi	r24, 0x30	; 48
    7eea:	08 f0       	brcs	.+2      	; 0x7eee <file_read_hex+0x3c>
		return(a - '0');
    7eec:	80 53       	subi	r24, 0x30	; 48
	return a;
}

static uint8_t file_read_hex(void) {
	return (gethexnib(file_read_byte()) << 4) + gethexnib(file_read_byte());
}
    7eee:	8c 0f       	add	r24, r28
    7ef0:	cf 91       	pop	r28
    7ef2:	08 95       	ret

00007ef4 <write_flash_page>:

void write_flash_page()
{
	uint16_t i = 0;

	eeprom_busy_wait ();
    7ef4:	f9 99       	sbic	0x1f, 1	; 31
    7ef6:	fe cf       	rjmp	.-4      	; 0x7ef4 <write_flash_page>

	boot_page_erase (address);
    7ef8:	20 91 28 01 	lds	r18, 0x0128
    7efc:	30 91 29 01 	lds	r19, 0x0129
    7f00:	83 e0       	ldi	r24, 0x03	; 3
    7f02:	f9 01       	movw	r30, r18
    7f04:	80 93 57 00 	sts	0x0057, r24
    7f08:	e8 95       	spm
	boot_spm_busy_wait ();      // Wait until the memory is erased.
    7f0a:	07 b6       	in	r0, 0x37	; 55
    7f0c:	00 fc       	sbrc	r0, 0
    7f0e:	fd cf       	rjmp	.-6      	; 0x7f0a <write_flash_page+0x16>
    7f10:	aa e2       	ldi	r26, 0x2A	; 42
    7f12:	b1 e0       	ldi	r27, 0x01	; 1
    7f14:	80 e0       	ldi	r24, 0x00	; 0
    7f16:	90 e0       	ldi	r25, 0x00	; 0

	for (i=0; i<SPM_PAGESIZE; i+=2)
	{
		// Set up little-endian word.
		uint16_t w = *((uint16_t*)(pagebuffer + i));
		boot_page_fill (address + i, w);
    7f18:	61 e0       	ldi	r22, 0x01	; 1
	boot_spm_busy_wait ();      // Wait until the memory is erased.

	for (i=0; i<SPM_PAGESIZE; i+=2)
	{
		// Set up little-endian word.
		uint16_t w = *((uint16_t*)(pagebuffer + i));
    7f1a:	4d 91       	ld	r20, X+
    7f1c:	5d 91       	ld	r21, X+
    7f1e:	fc 01       	movw	r30, r24
    7f20:	e2 0f       	add	r30, r18
    7f22:	f3 1f       	adc	r31, r19
		boot_page_fill (address + i, w);
    7f24:	0a 01       	movw	r0, r20
    7f26:	60 93 57 00 	sts	0x0057, r22
    7f2a:	e8 95       	spm
    7f2c:	11 24       	eor	r1, r1
	eeprom_busy_wait ();

	boot_page_erase (address);
	boot_spm_busy_wait ();      // Wait until the memory is erased.

	for (i=0; i<SPM_PAGESIZE; i+=2)
    7f2e:	02 96       	adiw	r24, 0x02	; 2
    7f30:	80 38       	cpi	r24, 0x80	; 128
    7f32:	91 05       	cpc	r25, r1
    7f34:	91 f7       	brne	.-28     	; 0x7f1a <write_flash_page+0x26>
		// Set up little-endian word.
		uint16_t w = *((uint16_t*)(pagebuffer + i));
		boot_page_fill (address + i, w);
	}

	boot_page_write(address);     // Store buffer in flash page.
    7f36:	85 e0       	ldi	r24, 0x05	; 5
    7f38:	f9 01       	movw	r30, r18
    7f3a:	80 93 57 00 	sts	0x0057, r24
    7f3e:	e8 95       	spm
	boot_spm_busy_wait();            // Wait until the memory is written.
    7f40:	07 b6       	in	r0, 0x37	; 55
    7f42:	00 fc       	sbrc	r0, 0
    7f44:	fd cf       	rjmp	.-6      	; 0x7f40 <write_flash_page+0x4c>

	boot_rww_enable ();
    7f46:	81 e1       	ldi	r24, 0x11	; 17
    7f48:	80 93 57 00 	sts	0x0057, r24
    7f4c:	e8 95       	spm
    7f4e:	08 95       	ret

00007f50 <__eeupd_byte_m328p>:
    7f50:	26 2f       	mov	r18, r22

00007f52 <__eeupd_r18_m328p>:
    7f52:	f9 99       	sbic	0x1f, 1	; 31
    7f54:	fe cf       	rjmp	.-4      	; 0x7f52 <__eeupd_r18_m328p>
    7f56:	92 bd       	out	0x22, r25	; 34
    7f58:	81 bd       	out	0x21, r24	; 33
    7f5a:	f8 9a       	sbi	0x1f, 0	; 31
    7f5c:	01 97       	sbiw	r24, 0x01	; 1
    7f5e:	00 b4       	in	r0, 0x20	; 32
    7f60:	02 16       	cp	r0, r18
    7f62:	39 f0       	breq	.+14     	; 0x7f72 <__eeupd_r18_m328p+0x20>
    7f64:	1f ba       	out	0x1f, r1	; 31
    7f66:	20 bd       	out	0x20, r18	; 32
    7f68:	0f b6       	in	r0, 0x3f	; 63
    7f6a:	f8 94       	cli
    7f6c:	fa 9a       	sbi	0x1f, 2	; 31
    7f6e:	f9 9a       	sbi	0x1f, 1	; 31
    7f70:	0f be       	out	0x3f, r0	; 63
    7f72:	08 95       	ret

00007f74 <__eeupd_word_m328p>:
    7f74:	01 96       	adiw	r24, 0x01	; 1
    7f76:	27 2f       	mov	r18, r23
    7f78:	0e 94 a9 3f 	call	0x7f52	; 0x7f52 <__eeupd_r18_m328p>
    7f7c:	0c 94 a8 3f 	jmp	0x7f50	; 0x7f50 <__eeupd_byte_m328p>

00007f80 <_exit>:
    7f80:	f8 94       	cli

00007f82 <__stop_program>:
    7f82:	ff cf       	rjmp	.-2      	; 0x7f82 <__stop_program>
